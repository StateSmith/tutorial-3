// Autogenerated with StateSmith 0.12.0-alpha+99dbe30d387ec88bb0e251bea536ac8980235987.
// Algorithm: Balanced1. See https://github.com/StateSmith/StateSmith/wiki/Algorithms

#nullable enable

using System;


namespace LightController
{
    // Generated state machine
    public class LightSm : LightSmBase
    {
        public enum EventId
        {
            DIM = 0,
            INC = 1,
            OFF = 2,
        }

        public const int EventIdCount = 3;

        public enum StateId
        {
            ROOT = 0,
            OFF = 1,
            ON_GROUP = 2,
            ON_HOT = 3,
            ON1 = 4,
            ON2 = 5,
        }

        public const int StateIdCount = 6;

        // event handler type
        private delegate void Func(LightSm sm);

        // Used internally by state machine. Feel free to inspect, but don't modify.
        public StateId stateId;

        // Used internally by state machine. Don't modify.
        private Func? ancestorEventHandler;

        // Used internally by state machine. Don't modify.
        private readonly Func?[] currentEventHandlers = new Func[EventIdCount];

        // Used internally by state machine. Don't modify.
        private Func? currentStateExitHandler;

        // State machine constructor. Must be called before start or dispatch event functions. Not thread safe.
        public LightSm()
        {
        }

        // Starts the state machine. Must be called before dispatching events. Not thread safe.
        public void Start()
        {
            ROOT_enter();
            // ROOT behavior
            // uml: TransitionTo(ROOT.<InitialState>)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.

                // Step 2: Transition action: ``.

                // Step 3: Enter/move towards transition target `ROOT.<InitialState>`.
                // ROOT.<InitialState> is a pseudo state and cannot have an `enter` trigger.

                // ROOT.<InitialState> behavior
                // uml: TransitionTo(OFF)
                {
                    // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.

                    // Step 2: Transition action: ``.

                    // Step 3: Enter/move towards transition target `OFF`.
                    OFF_enter();

                    // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                    this.stateId = StateId.OFF;
                    // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
                    return;
                } // end of behavior for ROOT.<InitialState>
            } // end of behavior for ROOT
        }

        // Dispatches an event to the state machine. Not thread safe.
        public void DispatchEvent(EventId eventId)
        {
            Func? behaviorFunc = this.currentEventHandlers[(int)eventId];

            while (behaviorFunc != null)
            {
                this.ancestorEventHandler = null;
                behaviorFunc(this);
                behaviorFunc = this.ancestorEventHandler;
            }
        }

        // This function is used when StateSmith doesn't know what the active leaf state is at
        // compile time due to sub states or when multiple states need to be exited.
        private void ExitUpToStateHandler(Func desiredStateExitHandler)
        {
            while (this.currentStateExitHandler != desiredStateExitHandler)
            {
                this.currentStateExitHandler!(this);
            }
        }


        ////////////////////////////////////////////////////////////////////////////////
        // event handlers for state ROOT
        ////////////////////////////////////////////////////////////////////////////////

        private void ROOT_enter()
        {
            // setup trigger/event handlers
            this.currentStateExitHandler = ptr_ROOT_exit;
        }

        // static delegate to avoid implicit conversion and garbage collection
        private static readonly Func ptr_ROOT_exit = (LightSm sm) => sm.ROOT_exit();
        private void ROOT_exit()
        {
        }


        ////////////////////////////////////////////////////////////////////////////////
        // event handlers for state OFF
        ////////////////////////////////////////////////////////////////////////////////

        private void OFF_enter()
        {
            // setup trigger/event handlers
            this.currentStateExitHandler = ptr_OFF_exit;
            this.currentEventHandlers[(int)EventId.INC] = ptr_OFF_inc;

            // OFF behavior
            // uml: enter / { Console.WriteLine("Light is: OFF"); }
            {
                // Step 1: execute action `Console.WriteLine("Light is: OFF");`
                Console.WriteLine("Light is: OFF");
            } // end of behavior for OFF
        }

        // static delegate to avoid implicit conversion and garbage collection
        private static readonly Func ptr_OFF_exit = (LightSm sm) => sm.OFF_exit();
        private void OFF_exit()
        {
            // adjust function pointers for this state's exit
            this.currentStateExitHandler = ptr_ROOT_exit;
            this.currentEventHandlers[(int)EventId.INC] = null;  // no ancestor listens to this event
        }

        // static delegate to avoid implicit conversion and garbage collection
        private static readonly Func ptr_OFF_inc = (LightSm sm) => sm.OFF_inc();
        private void OFF_inc()
        {
            // No ancestor state handles `inc` event.

            // OFF behavior
            // uml: INC TransitionTo(ON1)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
                OFF_exit();

                // Step 2: Transition action: ``.

                // Step 3: Enter/move towards transition target `ON1`.
                ON_GROUP_enter();
                ON1_enter();

                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                this.stateId = StateId.ON1;
                // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
                return;
            } // end of behavior for OFF
        }


        ////////////////////////////////////////////////////////////////////////////////
        // event handlers for state ON_GROUP
        ////////////////////////////////////////////////////////////////////////////////

        private void ON_GROUP_enter()
        {
            // setup trigger/event handlers
            this.currentStateExitHandler = ptr_ON_GROUP_exit;
            this.currentEventHandlers[(int)EventId.OFF] = ptr_ON_GROUP_off;
        }

        // static delegate to avoid implicit conversion and garbage collection
        private static readonly Func ptr_ON_GROUP_exit = (LightSm sm) => sm.ON_GROUP_exit();
        private void ON_GROUP_exit()
        {
            // adjust function pointers for this state's exit
            this.currentStateExitHandler = ptr_ROOT_exit;
            this.currentEventHandlers[(int)EventId.OFF] = null;  // no ancestor listens to this event
        }

        // static delegate to avoid implicit conversion and garbage collection
        private static readonly Func ptr_ON_GROUP_off = (LightSm sm) => sm.ON_GROUP_off();
        private void ON_GROUP_off()
        {
            // No ancestor state handles `off` event.

            // ON_GROUP behavior
            // uml: OFF TransitionTo(OFF)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
                ExitUpToStateHandler(ptr_ROOT_exit);

                // Step 2: Transition action: ``.

                // Step 3: Enter/move towards transition target `OFF`.
                OFF_enter();

                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                this.stateId = StateId.OFF;
                // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
                return;
            } // end of behavior for ON_GROUP
        }


        ////////////////////////////////////////////////////////////////////////////////
        // event handlers for state ON_HOT
        ////////////////////////////////////////////////////////////////////////////////

        private void ON_HOT_enter()
        {
            // setup trigger/event handlers
            this.currentStateExitHandler = ptr_ON_HOT_exit;
            this.currentEventHandlers[(int)EventId.DIM] = ptr_ON_HOT_dim;

            // ON_HOT behavior
            // uml: enter / { LightRed(); }
            {
                // Step 1: execute action `LightRed();`
                LightRed();
            } // end of behavior for ON_HOT
        }

        // static delegate to avoid implicit conversion and garbage collection
        private static readonly Func ptr_ON_HOT_exit = (LightSm sm) => sm.ON_HOT_exit();
        private void ON_HOT_exit()
        {
            // adjust function pointers for this state's exit
            this.currentStateExitHandler = ptr_ON_GROUP_exit;
            this.currentEventHandlers[(int)EventId.DIM] = null;  // no ancestor listens to this event
        }

        // static delegate to avoid implicit conversion and garbage collection
        private static readonly Func ptr_ON_HOT_dim = (LightSm sm) => sm.ON_HOT_dim();
        private void ON_HOT_dim()
        {
            // No ancestor state handles `dim` event.

            // ON_HOT behavior
            // uml: DIM TransitionTo(ON2)
            {
                // Step 1: Exit states until we reach `ON_GROUP` state (Least Common Ancestor for transition).
                ON_HOT_exit();

                // Step 2: Transition action: ``.

                // Step 3: Enter/move towards transition target `ON2`.
                ON2_enter();

                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                this.stateId = StateId.ON2;
                // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
                return;
            } // end of behavior for ON_HOT
        }


        ////////////////////////////////////////////////////////////////////////////////
        // event handlers for state ON1
        ////////////////////////////////////////////////////////////////////////////////

        private void ON1_enter()
        {
            // setup trigger/event handlers
            this.currentStateExitHandler = ptr_ON1_exit;
            this.currentEventHandlers[(int)EventId.DIM] = ptr_ON1_dim;
            this.currentEventHandlers[(int)EventId.INC] = ptr_ON1_inc;

            // ON1 behavior
            // uml: enter / { LightBlue(); }
            {
                // Step 1: execute action `LightBlue();`
                LightBlue();
            } // end of behavior for ON1
        }

        // static delegate to avoid implicit conversion and garbage collection
        private static readonly Func ptr_ON1_exit = (LightSm sm) => sm.ON1_exit();
        private void ON1_exit()
        {
            // adjust function pointers for this state's exit
            this.currentStateExitHandler = ptr_ON_GROUP_exit;
            this.currentEventHandlers[(int)EventId.DIM] = null;  // no ancestor listens to this event
            this.currentEventHandlers[(int)EventId.INC] = null;  // no ancestor listens to this event
        }

        // static delegate to avoid implicit conversion and garbage collection
        private static readonly Func ptr_ON1_dim = (LightSm sm) => sm.ON1_dim();
        private void ON1_dim()
        {
            // No ancestor state handles `dim` event.

            // ON1 behavior
            // uml: DIM TransitionTo(OFF)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
                ExitUpToStateHandler(ptr_ROOT_exit);

                // Step 2: Transition action: ``.

                // Step 3: Enter/move towards transition target `OFF`.
                OFF_enter();

                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                this.stateId = StateId.OFF;
                // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
                return;
            } // end of behavior for ON1
        }

        // static delegate to avoid implicit conversion and garbage collection
        private static readonly Func ptr_ON1_inc = (LightSm sm) => sm.ON1_inc();
        private void ON1_inc()
        {
            // No ancestor state handles `inc` event.

            // ON1 behavior
            // uml: INC TransitionTo(ON2)
            {
                // Step 1: Exit states until we reach `ON_GROUP` state (Least Common Ancestor for transition).
                ON1_exit();

                // Step 2: Transition action: ``.

                // Step 3: Enter/move towards transition target `ON2`.
                ON2_enter();

                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                this.stateId = StateId.ON2;
                // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
                return;
            } // end of behavior for ON1
        }


        ////////////////////////////////////////////////////////////////////////////////
        // event handlers for state ON2
        ////////////////////////////////////////////////////////////////////////////////

        private void ON2_enter()
        {
            // setup trigger/event handlers
            this.currentStateExitHandler = ptr_ON2_exit;
            this.currentEventHandlers[(int)EventId.DIM] = ptr_ON2_dim;
            this.currentEventHandlers[(int)EventId.INC] = ptr_ON2_inc;

            // ON2 behavior
            // uml: enter / { LightYellow(); }
            {
                // Step 1: execute action `LightYellow();`
                LightYellow();
            } // end of behavior for ON2

            // ON2 behavior
            // uml: enter / { count = 0; }
            {
                // Step 1: execute action `count = 0;`
                count = 0;
            } // end of behavior for ON2
        }

        // static delegate to avoid implicit conversion and garbage collection
        private static readonly Func ptr_ON2_exit = (LightSm sm) => sm.ON2_exit();
        private void ON2_exit()
        {
            // adjust function pointers for this state's exit
            this.currentStateExitHandler = ptr_ON_GROUP_exit;
            this.currentEventHandlers[(int)EventId.DIM] = null;  // no ancestor listens to this event
            this.currentEventHandlers[(int)EventId.INC] = null;  // no ancestor listens to this event
        }

        // static delegate to avoid implicit conversion and garbage collection
        private static readonly Func ptr_ON2_dim = (LightSm sm) => sm.ON2_dim();
        private void ON2_dim()
        {
            // No ancestor state handles `dim` event.

            // ON2 behavior
            // uml: DIM TransitionTo(ON1)
            {
                // Step 1: Exit states until we reach `ON_GROUP` state (Least Common Ancestor for transition).
                ON2_exit();

                // Step 2: Transition action: ``.

                // Step 3: Enter/move towards transition target `ON1`.
                ON1_enter();

                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                this.stateId = StateId.ON1;
                // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
                return;
            } // end of behavior for ON2
        }

        // static delegate to avoid implicit conversion and garbage collection
        private static readonly Func ptr_ON2_inc = (LightSm sm) => sm.ON2_inc();
        private void ON2_inc()
        {
            // No ancestor state handles `inc` event.

            // ON2 behavior
            // uml: 1. INC / { count++; }
            {
                // Step 1: execute action `count++;`
                count++;

                // Step 2: determine if ancestor gets to handle event next.
                // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
            } // end of behavior for ON2

            // ON2 behavior
            // uml: 2. INC / { Console.WriteLine("    Count: " + count); }
            {
                // Step 1: execute action `Console.WriteLine("    Count: " + count);`
                Console.WriteLine("    Count: " + count);

                // Step 2: determine if ancestor gets to handle event next.
                // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
            } // end of behavior for ON2

            // ON2 behavior
            // uml: INC [count >= 3] TransitionTo(ON_HOT)
            if (count >= 3)
            {
                // Step 1: Exit states until we reach `ON_GROUP` state (Least Common Ancestor for transition).
                ON2_exit();

                // Step 2: Transition action: ``.

                // Step 3: Enter/move towards transition target `ON_HOT`.
                ON_HOT_enter();

                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                this.stateId = StateId.ON_HOT;
                // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
                return;
            } // end of behavior for ON2
        }

        // Thread safe.
        public static string StateIdToString(StateId id)
        {
            switch (id)
            {
                case StateId.ROOT: return "ROOT";
                case StateId.OFF: return "OFF";
                case StateId.ON_GROUP: return "ON_GROUP";
                case StateId.ON_HOT: return "ON_HOT";
                case StateId.ON1: return "ON1";
                case StateId.ON2: return "ON2";
                default: return "?";
            }
        }

        // Thread safe.
        public static string EventIdToString(EventId id)
        {
            switch (id)
            {
                case EventId.DIM: return "DIM";
                case EventId.INC: return "INC";
                case EventId.OFF: return "OFF";
                default: return "?";
            }
        }
    }
}
